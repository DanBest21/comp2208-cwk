\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage[toc,page]{appendix}

\title{COMP2208 - Search Methods Coursework}
\author{Daniel Best (Student ID: 29777127)}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0.5pt}
\lfoot{Daniel Best}
\cfoot{\thepage}
\rfoot{COMP2208}
\graphicspath{ {./images/} }

\lstset{
	basicstyle=\ttfamily,
	columns=fullflexible,
	frame=single,
	breaklines=true,
	postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\begin{document}
	\maketitle
	
	\newpage
	
	\section{Approach}
	My approach to this assignment was to first create support classes that would handle any details that didn't directly relate to the search algorithm itself. These are as follows:
	
	\subsection{Node}
	This class defines both a singular node in the tree structure, as well as the entire tree structure itself by means of its \textbf{parent} and \textbf{children} variables. It contains a single \textbf{Grid} object, the \textbf{value} variable. It also implements the Comparable interface, where it compares an optional \textbf{estimatedCost} variable - a feature that was specifically added for the A* Search algorithm.

	\subsection{Grid}
	A class that handles the state by means of manipulating a \textbf{char[][]} multidimensional array. This class stores the actual state of the problem, storing the location of the \textbf{agent} ($\neg$) and all of the non-white space blocks; it also allows for that state to be manipulated in a multitude of ways:
	
	\begin{itemize}
		\item Generates the start and solution state.
		\item Moves the agent in the grid, thereby changing the location of both the agent and the block it moves to.
		\item Calculates the \textbf{Manhattan distance} between the Grid and another Grid object passed to it, which is used as the heuristic for A* Search.
	\end{itemize}
	
	\subsection{Search}
	An abstract class that defines a common start and solution state for each of the individual search methods, and provides a common \textbf{expandNode()} method, which generates the children of a given node.
	
	Using this \textbf{Search} class, I was able to easily implement a class for each of the four search algorithms:
	
	\subsection{Breadth First Search (BFS)}
	Uses a \textbf{Queue} to store expanded nodes, meaning nodes are checked in the order they are expanded.
	
	\subsection{Depth First Search (DFS)}
	Uses a \textbf{Stack} to store expanded nodes, meaning the last node to expanded is checked next.
	
	\subsection{Iterative Deepening Search (IDS)}
	Uses \textbf{Depth Limited Search (DLS)}, a modified version of \textbf{DFS} that does not expand nodes at a given \textbf{depth}, which then iteratively increases this limit. 
	
	\subsection{A* Heuristic Search}
	Makes use of an evaluation function to determine which node to pick next, which is the \textbf{depth} of the node plus the \textbf{Manhattan distance (heuristic)} to the solution.
	
	\section{Evidence of Search Methods}
	When testing my search methods, I found 21 start states that each corresponded to a problem which has an optimal solution at a different depth (from 0 to 20). The solution state was always the same, as specified by the problem in the assignment briefing.
	
	\subsection{Breadth First Search (BFS)}
	\textbf{Example 1 (depth 4):}
	
	In this initial state, the agent has three possible directions that it can move.
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{BFS-1-1.png}
	\end{figure}

	These three new nodes are then expanded in the order that they were first generated.
	\begin{multicols}{3}[\columnsep=2cm]
		\includegraphics[width=0.3\textwidth,keepaspectratio]{BFS-1-2-1.png}
		\columnbreak
		\includegraphics[width=0.3\textwidth,keepaspectratio]{BFS-1-2-2.png}
		\columnbreak
		\includegraphics[width=0.3\textwidth,keepaspectratio]{BFS-1-2-3.png}
	\end{multicols}

	The algorithm then expands the first child node in \textbf{Fringe 2}, which generates the first nodes that are at a depth of 2.
	\begin{figure}[h]
		\centering
		\includegraphics{BFS-1-3.png}
	\end{figure}

	This process then repeats indefinitely until the correct node is found. At the 21st expansion to the fringe, we can see the correct node being found.
	\begin{figure}[h]
		\centering
		\includegraphics{BFS-1-4.png}
	\end{figure}

	However, due to the uninformed nature of the algorithm, it does not recognise this as it only checks if it is in the goal state when taking it off the \textbf{Queue}. It therefore continues to go through each node on depth 3, and all the nodes in depth 4 that exist prior to that node - a further 44 expansions. 
	
	\newpage
	\textbf{Fringe 65} shows the node that was generated prior to the goal state node being expanded.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.4\textheight]{BFS-1-5.png}
	\end{figure}
	
	The following is a breakdown of the solution of this problem, as retrieved by this search.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.33\textheight]{BFS-1-6.png}
	\end{figure}
	
	\newpage
	\textbf{Example 2 (depth 14):}
	
	The original problem provided for the assignment has an optimal solution at \textbf{depth 14}, but running BFS on it causes a \textbf{Java Heap space error} due to the number of generated nodes (space complexity).
	
	The algorithm starts in the same way that it did for the previous problem, by expanding the root node, and then by expanding each subsequent child in the order that they were generated.
	
	\begin{figure}[h]	
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{BFS-2-1.png}
	\end{figure}

	\newpage
		
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[width=0.4\textwidth,keepaspectratio]{BFS-2-2-1.png}
		\columnbreak
		\includegraphics[width=0.4\textwidth,keepaspectratio]{BFS-2-2-2.png}
	\end{multicols}
	
	It then continues this process of first checking all of the nodes on a depth in the order they were generated, and then moving down to the next depth.
	
	Eventually however, it will run into an \textbf{OutOfMemoryException} due to running out of Java Heap space.
	
	\begin{figure}[h]	
		\centering
		\includegraphics[height=0.4\textheight,keepaspectratio]{BFS-2-3.png}
	\end{figure}
	
	\newpage
	\subsection{Depth First Search (DFS)}
	\textbf{Example 1 (depth 5):}
	
	Implementing DFS for this type of problem has an obvious flaw in that the nodes are generated in an ordered manner. In the case of my algorithm, this is left, right, up and down. As such, the node added to the top of the \textbf{Stack} will always be the last possible direction. In this particular example, the agent will keep moving down and then back up again, since these will be the latest nodes generated.
	
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[width=0.5\textwidth,keepaspectratio]{DFS-1-1.png}
		\columnbreak
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-1-2.png}
	\end{multicols}
	
	\newpage
	This means that unless modified accordingly, i.e. so the order of the generated nodes is randomised, the algorithm will almost certainly never find a solution.
		
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-1-3.png}
		\columnbreak
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-1-4.png}
	\end{multicols}

	\newpage
	Eventually, this will cause an \textbf{OutOfMemoryException}, since it will repeat this process indefinitely, with the only difference being that the depth has increased by one each time.
	
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-1-5.png}
		\columnbreak
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-1-6.png}
	\end{multicols}

	\newpage
	\textbf{Example 2 (depth 5 with random order):}
	
	In order to get DFS working with this problem, the order in which the generated nodes are placed onto the \textbf{Stack} should be randomised. This is done by using the \textbf{Collections.shuffle()} function on the children list. Below, we can see the effect this has on the third and fourth node expansion.
	
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-2-1.png}
		\columnbreak
		\includegraphics[width=0.4\textwidth,keepaspectratio]{DFS-2-2.png}
	\end{multicols}

	\newpage
	By completely arbitrary movements, the algorithm will eventually find some solution.
	
	\begin{figure}[h]	
		\centering
		\includegraphics[height=0.7\textheight,keepaspectratio]{DFS-2-3.png}
	\end{figure}

	However, this solution is almost guaranteed to not be the optimal solution. The solution returned here is in 10967 steps, whereas the optimal solution for this problem is in merely 5.
	
	\begin{figure}[h]	
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{DFS-2-4.png}
	\end{figure}

	\newpage
	Due to the random nature of this algorithm, the solution returned is very likely to be different each time, with the below showing what the algorithm returns on another run-through.
	
	\begin{figure}[h]	
		\centering
		\includegraphics[height=0.6\textheight,keepaspectratio]{DFS-2-5.png}
	\end{figure}
	
	\newpage
	\subsection{Iterative Deepening Search (IDS)}
	\textbf{Example 1 (depth 6):}
	
	The IDS algorithm begins by calling DLS with a limit of depth 1. The agent in this initial state has three possible directions that it can move in. Each of these children are then also checked to see if they are the goal state.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.7\textheight]{IDS-1-1.png}
	\end{figure}

	\newpage
	The IDS then increases the limit to 2, and performs another DLS on this limit.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.7\textheight]{IDS-1-2.png}
	\end{figure}

	\newpage
	However, because the limit is now 2, we also expand the nodes at depth 1, and then check the nodes at depth 2 that are generated from these expansions.
	\begin{multicols}{3}[\columnsep=2cm]
		\includegraphics[width=0.3\textwidth,keepaspectratio]{IDS-1-3-1.png}
		\columnbreak
		\includegraphics[width=0.3\textwidth,keepaspectratio]{IDS-1-3-2.png}
		\columnbreak
		\includegraphics[width=0.3\textwidth,keepaspectratio]{IDS-1-3-3.png}
	\end{multicols}

	\newpage
	Since none of these nodes contain the goal state (which can actually be found at depth 6), we repeat this process until the goal state is found.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.7\textheight]{IDS-1-4.png}
	\end{figure}

	\newpage
	If we look at the node expansions prior to this, we can see the DFS nature of the algorithm, as the next node selected is always the last generated. The next node expansion contains the goal state that was seen in the previous image (labelled \textbf{Fringe 215}).
	\begin{multicols}{3}[\columnsep=2cm]
		\includegraphics[width=0.3\textwidth,keepaspectratio]{IDS-1-5-1.png}
		\columnbreak
		\includegraphics[width=0.3\textwidth,keepaspectratio]{IDS-1-5-2.png}
		\columnbreak
		\includegraphics[width=0.3\textwidth,keepaspectratio]{IDS-1-5-3.png}
	\end{multicols}
	
	\newpage
	The optimal solution was therefore found at depth 6.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.6\textheight]{IDS-1-6.png}
	\end{figure}

	\newpage
	\textbf{Example 2 (depth 15):}
	
	Whilst IDS has a better space complexity than BFS because it handles works in a DFS manner with its node expansion, it is not immune to space constraints at a large enough problem size. The following problem has an optimal solution at a depth of 15.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.6\textheight]{IDS-2-1.png}
	\end{figure}
	
	\newpage
	This means that like BFS, a failed IDS at a certain depth will cause a \textbf{Java heap space error}.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.43\textheight]{IDS-2-2.png}
	\end{figure}
	
	\newpage
	\subsection{A* Heuristic Search}
	\textbf{Example 1 (depth 3):}
	
	A* Search works differently to the other searches in the sense that it is an informed search, meaning the algorithm has additional information in regards to what node it should select next to expand.
	
	Looking through a simple example, we can see that a solution that has a depth of 3 can be found by expanding 3 nodes.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-1-1.png}
	\end{figure}

	\newpage
	Since the third child has the lowest evaluation function value (current depth of 1 plus the heuristic of 2), the \textbf{PriorityQueue} prioritises that as the next node, and thus it is selected as the next node to be expanded.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-1-2.png}
	\end{figure}

	\newpage
	In the next step, we select the third child from the \textbf{Fringe 2} node expansion seen above. Despite the fact that it has a higher depth than some of the other possible nodes that can be expanded, its evaluation function is lower thanks to the fact that the heuristic is merely 1.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-1-3.png}
	\end{figure}

	\newpage
	We have now found a solution, which the \textbf{PriorityQueue} will select regardless as it has the lowest evaluation function value.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-1-4.png}
	\end{figure}

	\newpage
	\textbf{Example 2 (depth 15):}
	
	Since A* is a smarter searching algorithm, it is capable of solving problems that the other uninformed search methods cannot due to \textbf{Java heap space errors}. For instance, it is able to find a solution for the problem that has an optimal solution at depth 15 that IDS was unable to find.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-2-1.png}
	\end{figure}

	\newpage
	The next node that is expanded is the one with the lowest value from the evaluation function, which was the first child in this case.
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-2-2.png}
	\end{figure}

	\newpage
	This process continues until a solution is found - here is the last node expansion performed before the goal state is discovered.
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-2-3.png}
	\end{figure}

	\newpage
	You would have noticed that the last expanded node does not contain the solution - this is because these nodes have an equal evaluation function value, so the way that they are selected in this situation is completely down to the implementation of the Java \textbf{PriorityQueue} structure. The solution node can actually be seen being generated in the node generation labelled \textbf{Fringe 32385}, two nodes before the point at which the final expansion took place.
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.75\textheight]{AStar-2-4.png}
	\end{figure}

	\newpage
	The following solution is then found, which corresponds to the optimal solution that exists at 15 steps.
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[height=0.8\textheight,keepaspectratio]{AStar-2-5-1.png}
		\columnbreak
		\includegraphics[height=0.8\textheight,keepaspectratio]{AStar-2-5-2.png}
	\end{multicols}

	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{AStar-2-6.png}
	\end{figure}
	
	\newpage
	\section{Scalability Study}
	As explained above, the scalability study was conducted using 21 states, each of which corresponded to a problem that had an optimal solution from 0 to 20. For completeness, I have attached these initial states, as seen in appendix \ref{appendix:start}.
	\begin{figure}[h]	
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{Results-1.png}
	\end{figure}
	\begin{figure}[h]	
		\centering
		\includegraphics[width=0.75\textwidth,keepaspectratio]{Results-2.png}
	\end{figure}

	\newpage
	The below graph visualises these results. Take note of the logarithmic scale used for the nodes generated.
	\begin{figure}[h]	
		\centering
		\includegraphics[height=0.5\textheight,keepaspectratio]{Results-Plot.png}
	\end{figure}

	From this data, you may extrapolate that the DFS with a random order is the best performing algorithm for problems with larger depth solutions. However, although it may be quicker to find these solutions, they are almost guaranteed to not be \textbf{optimal}. It is also worth noting that due to the arbitrary nature of this algorithm, it is actually the worst performing search at the earlier depth problems.
	
	Looking at the other algorithms, it is clear that A* is the best performing algorithm in terms of time complexity, however it is also clear that it is exponential based on the problem size. BFS and IDS would continue to rise exponentially too if they did not run into space complexity issues, but have a worse time complexity than A*. For the most part, IDS is better than BFS, but this is dependent on where in the tree structure the goal state is located.
	
	\newpage
	\section{Extras and Limitations}
	For my extras, I implemented an algorithm (as part of the \textbf{generateStartState()} function in the \textbf{Grid} class) that places a number of collision blocks (represented by a \textbf{!}) on the grid at random spots on the grid. This excludes the start state positions of the blocks and the agent, as well as the intended position of the blocks at the end state. The exact number of collision blocks is controlled through the constant \textbf{COLLISIONS\_NUM} in the \textbf{Grid} class.
	
	The position of these blocks can potentially have a negative effect in regards to optimal depth and a positive effect in terms of the time complexity (assuming the problem is solvable), as can be seen when performing A* Search on the default state.
	\begin{figure}[h]	
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{Extras-1.png}
	\end{figure}

	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{Extras-2.png}
	\end{figure}

	The solution found was actually found in \textbf{22056} nodes, as opposed to the \textbf{83248} nodes that the unmodified version of this problem had for A* Search.
	
	\newpage
	I also implemented an alternative heuristic for the A* Search algorithm in the form of the \textbf{Euclidean distance} algorithm. This is switched on by means of constant in the \textbf{Grid} class - \textbf{EUCLID}. The \textbf{calculateEuclideanDistance()} function is then used as opposed to the standard \textbf{calculateManhattanDistance()} function.
	
	\begin{figure}[h]	
		\centering
		\includegraphics[width=\textwidth,keepaspectratio]{Extras-3.png}
	\end{figure}

	The heuristic is clearly different at the third node expansion, as the \textbf{Manhattan distance} is always an integer.
	\begin{multicols}{2}[\columnsep=2cm]
		\includegraphics[width=0.35\textwidth,keepaspectratio]{Extras-4-1.png}
		\columnbreak
		\includegraphics[width=0.5\textwidth,keepaspectratio]{Extras-4-2.png}
	\end{multicols}

	\newpage
	The solution that it finds in this case is identical to what was found with the \textbf{Manhattan distance} heuristic, however other problems may perform better or worse if this heuristic is used.
	\begin{figure}[h]	
		\centering
		\includegraphics[height=0.5\textheight,keepaspectratio]{Extras-5.png}
	\end{figure}

	In regards to limitations, the space complexity of my solution could be significantly improved if I were to refactor the \textbf{Grid} class to use something other than a HashMap to store the \textbf{blockPositions}. In terms of the scalability study, I could have ran the DFS algorithm on each of the states multiple times so that a more accurate average could be taken. I also could have tested A* and DFS at higher depths to determine at what point each of them would fail to find a solution.
	
	\newpage
	\begin{appendices}
		\section{Problem Start States}
		\label{appendix:start}
		
		\begin{center}
			\begin{tabular}{c c c c}
				\includegraphics[width=0.135\textwidth,keepaspectratio]{State-0.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-1.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-2.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-3.png} \\
				State 0 & State 1 & State 2 & State 3 \\
				\includegraphics[width=0.135\textwidth,keepaspectratio]{State-4.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-5.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-6.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-7.png} \\
				State 4 & State 5 & State 6 & State 7 \\
				\includegraphics[width=0.135\textwidth,keepaspectratio]{State-8.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-9.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-10.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-11.png} \\
				State 8 & State 9 & State 10 & State 11 \\
				\includegraphics[width=0.135\textwidth,keepaspectratio]{State-12.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-13.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-14.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-15.png} \\
				State 12 & State 13 & State 14 & State 15 \\
				\includegraphics[width=0.135\textwidth,keepaspectratio]{State-16.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-17.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-18.png} & \includegraphics[width=0.135\textwidth,keepaspectratio]{State-19.png} \\
				State 16 & State 17 & State 18 & State 19
			\end{tabular}
		
			\begin{figure}[h]	
				\centering
				\includegraphics[width=0.135\textwidth,keepaspectratio]{State-20.png}
			\end{figure} 
			State 20
		\end{center}
	
		\newpage
		\section{Code}
		\label{appendix:code}
		
		\subsection{Node}
\begin{lstlisting}[language=Java]
package Tree;

import java.util.ArrayList;
import java.util.List;

// Class that defines a Node, which is used to form a Tree structure by means of the parent and children variables.
public class Node implements Comparable<Node>
{
	private final Grid value;
	private final Node parent;
	private final List<Node> children;
	private double estimatedCost;

	public Node(Grid value, Node parent)
	{
		this.value = value;
		this.parent = parent;
		this.children = new ArrayList<>();
	}
	
	public Grid getValue()
	{
		return value;
	}
	
	public Node getParent()
	{
		return parent;
	}
	
	public List<Node> getChildren()
	{
		return children;
	}
	
	// Method that returns the depth of the Node in the tree.
	public int getDepth()
	{
		int depth = 0;
		Node node = this;
	
	while (node.parent != null)
	{
		depth++;
		node = node.parent;
	}
	
		return depth;
	}
	
	public void setEstimatedCost(double estimatedCost)
	{
		this.estimatedCost = estimatedCost;
	}
	
	public double getEstimatedCost()
	{
		return estimatedCost;
	}
	
	public void addChild(Node child)
	{
		this.children.add(child);
	}
	
	// compareTo() method that defines how Nodes work as a Comparable, which is necessary for use in a PriorityQueue.
	public int compareTo(Node node)
	{
		return Double.compare(this.getEstimatedCost(), node.getEstimatedCost());
	}
}
\end{lstlisting}
		
		\newpage
		\subsection{Grid}
\begin{lstlisting}[language=Java,mathescape=true]
package Tree;

import java.util.*;

// Class that stores the information about the grid and its current state, and the methods that can be used to manipulate it.
public class Grid
{
	private final int size;
	private final char[][] grid;
	private int agentPosition;
	private Direction lastDirection = null;
	private Map<Character, Integer> blockPositions = new HashMap<>();
	
	private static final char A = '$\neg$';
	private static final char E = 'W';
	private static final char C = '!';
	
	private static final int COLLISIONS_NUM = 0;
	private static final boolean EUCLID = true;
	
	public Grid(int size)
	{
		this.size = size;
		this.grid = new char[size][size];
	
		for (int i = 0; i < size; i++)
		{
			for (int j = 0; j < size; j++)
			{
				grid[i][j] = E;
			}
		}
	}

	public Grid(char[][] grid, int agentPosition, Map<Character, Integer> blockPositions)
	{
		this.size = grid.length;
		this.grid = grid;
		this.agentPosition = agentPosition;
		this.blockPositions = blockPositions;
	}

	// Method that automatically generates a starting grid based on its size.
	public void generateStartingGrid()
	{
		int blockNumber = size - 1;
		char block = 'a';

		blockPositions.clear();

		for (int i = 0; i < blockNumber; i++)
		{
			setBlockPosition(block, i, size - 1);
			block++;
		}

		setAgentPosition(size - 1, size - 1);

		// If collisions are turned on.
		if (COLLISIONS_NUM > 0)
		{
			List<Integer> possiblePositions = new ArrayList<>();

			// Collect a list of all possible locations - i.e. any location that is not needed for the agent and blocks in the start state, or the blocks in the solution state.
			for (int i = 0; i < (size * (size - 1)); i++)
			{
				if ((i - 1) % size != 0 || i == 1)
					possiblePositions.add(i);
			}

			Random random = new Random();

			// Randomly select an index of the possible positions, add the collision block, and then remove it from the index.
			for (int i = 0; i < COLLISIONS_NUM; i++)
			{
				int index = random.nextInt(possiblePositions.size());
				int position = possiblePositions.get(index);
				addCollisionBlock(getXCoord(position), getYCoord(position));
				possiblePositions.remove(index);
			}
		}
	}

	// IMPORTANT: This function only works if the size of the grid is 4x4, i.e. size = 4.
	// Method that sets a custom starting position based on the depth value provided.
	public void generateStartingGrid(int depth)
	{
		blockPositions.clear();

		switch (depth)
		{
			case 0:
				setBlockPosition('a', 1, 1);
				setBlockPosition('b', 1, 2);
				setBlockPosition('c', 1, 3);
				setAgentPosition(2, 1);
				break;
			case 1:
				setBlockPosition('a', 1, 1);
				setBlockPosition('b', 0, 2);
				setBlockPosition('c', 1, 3);
				setAgentPosition(1, 2);
				break;
			case 2:
				setBlockPosition('a', 0, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 3);
				setAgentPosition(1, 2);
				break;
			case 3:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 2);
				setAgentPosition(1, 3);
				break;
			case 4:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 2);
				setAgentPosition(2, 3);
				break;
			case 5:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 2);
				setAgentPosition(2, 2);
				break;
			case 6:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 2);
				setAgentPosition(0, 1);
				break;
			case 7:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 2);
				setAgentPosition(0, 0);
				break;
			case 8:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 1, 2);
				setAgentPosition(1, 0);
				break;
			case 9:
				setBlockPosition('a', 1, 3);
				setBlockPosition('b', 1, 2);
				setBlockPosition('c', 2, 3);
				setAgentPosition(0, 3);
				break;
			case 10:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 2);
				setBlockPosition('c', 2, 3);
				setAgentPosition(1, 3);
				break;
			case 11:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 2, 3);
				setAgentPosition(1, 2);
				break;
			case 12:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 2, 3);
				setAgentPosition(0, 2);
				break;
			case 13:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 2, 3);
				setAgentPosition(0, 1);
				break;
			case 14:
				generateStartingGrid();
				break;
			case 15:
				setBlockPosition('a', 2, 1);
				setBlockPosition('b', 1, 1);
				setBlockPosition('c', 0, 1);
				setAgentPosition(0, 0);
				break;
			case 16:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 3, 3);
				setAgentPosition(2, 1);
				break;
			case 17:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 3, 3);
				setAgentPosition(2, 0);
				break;
			case 18:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 3, 3);
				setAgentPosition(0, 0);
				break;
			case 19:
				setBlockPosition('a', 0, 3);
				setBlockPosition('b', 1, 3);
				setBlockPosition('c', 3, 2);
				setAgentPosition(0, 0);
				break;
			case 20:
				setBlockPosition('a', 3, 1);
				setBlockPosition('b', 3, 3);
				setBlockPosition('c', 3, 2);
				setAgentPosition(2, 0);
				break;
		}
	}

	// Method that automatically generates the solution state.
	public void generateSolutionGrid()
	{
		int blockNumber = size - 1;
		char block = (char) ('a' + blockNumber - 1);

		blockPositions.clear();

		for (int i = blockNumber; i > 0; i--)
		{
			setBlockPosition(block, 1, i);
			block--;
		}
	}

	// Function that returns the grid.
	// Since multidimensional arrays are treated as objects in Java, we need to make a new one and return that to avoid any conflicts between Grid objects.
	public char[][] getGrid()
	{
		char[][] newGrid = new char[size][size];

		for (int i = 0; i < size; i++)
		{
			System.arraycopy(grid[i], 0, newGrid[i], 0, grid[i].length);
		}

		return newGrid;
	}

	// Overridden toString() method to define how a Grid object should be output as a String.
	@Override
	public String toString()
	{
		String printString = "";

		for (int i = 0; i < size; i++)
		{
			for (int j = 0; j < size; j++)
			{
				printString = printString + grid[i][j];

				if (j != size - 1)
					printString = printString + " ";
			}

			printString = printString + "\n";
		}

		return printString;
	}

	// Function that sets a position on the grid to a block.
	private void setBlockPosition(char block, int x, int y)
	{
		grid[y][x] = block;

		// If the block isn't the empty block, or the agent block, then we want to update where it is in the blockPositions HashMap.
		if (block != E && block != A)
		{
			blockPositions.put(block, x + (size * y));
		}
	}

	// Method that sets the position of the agent on the grid.
	private void setAgentPosition(int x, int y)
	{
		grid[y][x] = A;
		agentPosition = x + (size * y);
	}

	private int getXCoord(int position)
	{
		return position % size;
	}

	private int getYCoord(int position)
	{
		return position / size;
	}

	public int getAgentPosition()
	{
		return agentPosition;
	}

	// Function that returns the block position of any entry in the blockPositions HashMap.
	private int getBlockPosition(char block)
	{
		if (blockPositions.containsKey(block))
			return blockPositions.get(block);

		return -1;
	}

	public Map<Character, Integer> getBlockPositions()
	{
		return blockPositions;
	}

	// Method that moves the agent in the provided direction.
	public void moveAgent(Direction direction)
	{
		int x = getXCoord(agentPosition);
		int y = getYCoord(agentPosition);
	
		// Swap the agent and the block based on the direction specified.
		switch (direction)
		{
			case LEFT:
				if (x != 0 && grid[y][x - 1] != C)
				{
					setBlockPosition(grid[y][x - 1], getXCoord(agentPosition), getYCoord(agentPosition));
					setAgentPosition(x - 1, y);
					lastDirection = Direction.LEFT;
				}
				break;
			case RIGHT:
				if (x != size - 1 && grid[y][x + 1] != C)
				{
					setBlockPosition(grid[y][x + 1], getXCoord(agentPosition), getYCoord(agentPosition));
					setAgentPosition(x + 1, y);
					lastDirection = Direction.RIGHT;
				}
				break;
			case UP:
				if (y != 0 && grid[y - 1][x] != C)
				{
					setBlockPosition(grid[y - 1][x], getXCoord(agentPosition), getYCoord(agentPosition));
					setAgentPosition(x, y - 1);
					lastDirection = Direction.UP;
				}
				break;
			case DOWN:
				if (y != size - 1 && grid[y + 1][x] != C)
				{
					setBlockPosition(grid[y + 1][x], getXCoord(agentPosition), getYCoord(agentPosition));
					setAgentPosition(x, y + 1);
					lastDirection = Direction.DOWN;
				}
				break;
		}
	}

	public Direction getLastDirection()
	{
		return lastDirection;
	}

	// Method that returns a boolean to see if two Grid objects have the same char[][] grid.
	public boolean equals(Grid solution)
	{
		boolean equal;

		for (int i = 0; i < size; i++)
		{
			for (int j = 0; j < size; j++)
			{
				equal = grid[i][j] == solution.grid[i][j];

				if (!equal && grid[i][j] != A && grid[i][j] != C)
					return false;
			}
		}

		return true;
	}

	// Method that adds a collision block at the given x and y co-ordinates.
	private void addCollisionBlock(int x, int y)
	{
		int position = x + (size * y);

		if (blockPositions.containsValue(position) || getAgentPosition() == position)
			System.out.println("Cannot add collision block to co-ordinate (" + x + ", " + ") as it is already occupied by a block or the agent!");
		else
			grid[y][x] = '!';
	}

	public double calculateDistance(Grid solution)
	{
		double distance = 0;
	
		for (Map.Entry entry : blockPositions.entrySet())
		{
			int gridPosition = (int) entry.getValue();
			int solutionPosition = solution.getBlockPosition((char) entry.getKey());
	
		int gridX = getXCoord(gridPosition);
		int gridY = getYCoord(gridPosition);
		int solutionX = getXCoord(solutionPosition);
		int solutionY = getYCoord(solutionPosition);
	
		if (EUCLID)
			distance = distance + calculateEuclideanDistance(gridX, gridY, solutionX, solutionY);
		else
		distance = distance + calculateManhattanDistance(gridX, gridY, solutionX, solutionY);
		}
	
		return distance;
	}

	// Function that calculates the Manhattan Distance between a position on this grid and on the solution grid.
	private int calculateManhattanDistance(int gridX, int gridY, int solutionX, int solutionY)
	{
		return Math.abs(gridX - solutionX) + Math.abs(gridY - solutionY);
	}

	// Function that calculates the Euclidean Distance between a position on this grid and on the solution grid.
	private double calculateEuclideanDistance(int gridX, int gridY, int solutionX, int solutionY)
	{
		return Math.sqrt(Math.pow((gridX - solutionX), 2) + Math.pow((gridY - solutionY), 2));
	}
}
\end{lstlisting}
		
		\subsection{Direction}
\begin{lstlisting}[language=Java]
package Tree;

public enum Direction
{
	LEFT,
	RIGHT,
	UP,
	DOWN
}
\end{lstlisting}
		
		\newpage
		\subsection{Search}
\begin{lstlisting}[language=Java]
package Search;

import Tree.*;

import java.util.HashMap;
import java.util.Map;

// Abstract search class that defines a common start and solution state, and provides a common expandNode() method.
public abstract class Search
{
	private static final int N = 4;

	final Grid startState = new Grid(N);
	final Grid solutionState = new Grid(N);
	private int nodesGenerated = 1;
	private int fringeCount = 1;
	final boolean debugMode;

	Search(boolean debugMode)
	{
		this.debugMode = debugMode;
		solutionState.generateSolutionGrid();
	}

	public void setStartingGrid(int depth)
	{
		startState.generateStartingGrid(depth);
	}

	public Grid getStartingGrid()
	{
		return startState;
	}

	public int getNodesGenerated()
	{
		return nodesGenerated;
	}

	// Function that expands the given node by generating every possible successor node, i.e. the directions in which the agent can move.
	void expandNode(Node node)
	{
		Grid currentGrid = node.getValue();

		if (debugMode)
		{
			System.out.println("------------- Fringe " + fringeCount + " ---------------\n");
			System.out.println("Selected node (depth " + node.getDepth() + "):\n" + node.getValue() + "\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
		}

		// For each direction, attempt to move the agent in that direction
		for (Direction dir : Direction.values())
		{
			Map<Character, Integer> blockPositions = new HashMap<>();

			for (Map.Entry entry : currentGrid.getBlockPositions().entrySet())
			{
				char block = (char)entry.getKey();
				int position = (int)entry.getValue();

				blockPositions.put(block, position);
			}

			Grid newGrid = new Grid(currentGrid.getGrid(), currentGrid.getAgentPosition(), blockPositions);

			newGrid.moveAgent(dir);

			if (!newGrid.equals(currentGrid))
			{
				Node newNode = new Node(newGrid, node);
				node.addChild(newNode);

				nodesGenerated++;

				if (debugMode)
					System.out.println(newNode.getValue());
			}
		}

		fringeCount++;
	}

	Node returnSolution(Node node)
	{
		if (debugMode)
		{
			System.out.println("--------- Solution Node (depth " + node.getDepth() + ") ---------\n");
			System.out.println(node.getValue());
			System.out.println("-------------------------------------------\n");
		}

		return node;
	}

	public abstract Node search();
}
\end{lstlisting}
		
		\newpage
		\subsection{BFS}
\begin{lstlisting}[language=Java]
package Search;

import java.util.LinkedList;
import java.util.Queue;
import Tree.Node;

// Class that implements the Breadth First Search (BFS) algorithm by using a Queue to manage the fringe.
public class BFS extends Search
{
	private final Queue<Node> fringe = new LinkedList<>();
	
	public BFS(boolean debugMode)
	{
		super(debugMode);
	}
	
	public Node search()
	{
		Node node = new Node(startState, null);
	
		fringe.add(node);
	
		while (!fringe.isEmpty())
		{
			node = fringe.remove();
		
			// Return the node if it is the solution state.
			if (node.getValue().equals(solutionState))
				return returnSolution(node);
		
			expandNode(node);
		
			// Add all the children to the queue, so they 'join the back of the queue'.
			fringe.addAll(node.getChildren());
		}
	
		return null;
	}
}	
\end{lstlisting}
		
		\newpage
		\subsection{DFS}
\begin{lstlisting}[language=Java]
package Search;

import Tree.Node;

import java.util.Collections;
import java.util.List;
import java.util.Stack;

// Class that implements the Depth First Search (DFS) algorithm by using a Stack to manage the fringe.
public class DFS extends Search
{
	private final Stack<Node> fringe = new Stack<>();
	private final boolean randomOrder;
	
	public DFS(boolean randomOrder, boolean debugMode)
	{
		super(debugMode);
		this.randomOrder = randomOrder;
	}
	
	public Node search()
	{
		Node node = new Node(startState, null);
	
		fringe.push(node);
	
		while (!fringe.isEmpty())
		{
			node = fringe.pop();
		
			// Return the node if it is the solution state.
			if (node.getValue().equals(solutionState))
				return returnSolution(node);
			
			expandNode(node);
			
			List<Node> children = node.getChildren();
			
			// If the order of nodes is supposed to be random, call Collections.shuffle on the children ArrayList.
			if (randomOrder)
				Collections.shuffle(children);
			
			// Add all of the children to the Stack, so they are the next nodes to be checked.
			fringe.addAll(children);
		}
	
		return null;
	}
}
\end{lstlisting}
		
		\newpage
		\subsection{IDS}
\begin{lstlisting}[language=Java]
package Search;

import Tree.Node;

import java.util.List;
import java.util.Stack;

// Class that implements the Iterative Deepening Search (IDS) algorithm by using a Depth Limited Search (DLS), a modified version of DFS that stops at a certain limit, and then iterates this algorithm until a solution is found.
public class IDS extends Search
{
	private final Stack<Node> fringe = new Stack<>();
	
	public IDS(boolean debugMode)
	{
		super(debugMode);
	}
	
	public Node search()
	{
		Node solution = null;
		int i = 1;
	
		// While the solution has not been returned by DLS, increase the limit by 1.
		while (solution == null)
		{
			solution = depthLimitedSearch(i);
			i++;
		}
	
		return solution;
	}
	
	private Node depthLimitedSearch(int limit)
	{
		Node node = new Node(startState, null);
	
		fringe.push(node);
	
		while (!fringe.isEmpty())
		{
			node = fringe.pop();
		
			// Return the node if it is the solution state.
			if (node.getValue().equals(solutionState))
				return returnSolution(node);
		
			// If the limit has been reached, then do not expand this node.
			if (node.getDepth() == limit)
				continue;
		
			expandNode(node);
		
			List<Node> children = node.getChildren();
		
			// As with DFS, add all of the children to the Stack, so they are the next nodes to be checked.
			fringe.addAll(children);
		}
	
		return null;
	}
}
\end{lstlisting}
		
		\newpage
		\subsection{AStar}
\begin{lstlisting}[language=Java]
package Search;

import Tree.Node;

import java.util.PriorityQueue;
import java.util.Queue;

// Class that implements the A* Heuristic Search algorithm by using a PriorityQueue that prioritises nodes by their heuristic.
public class AStar extends Search
{
	private final Queue<Node> fringe = new PriorityQueue<>();
	
	public AStar(boolean debugMode)
	{
		super(debugMode);
	}
	
	public Node search()
	{
		Node node = new Node(startState, null);
		
		// Get the estimated cost of the node - the Manhattan distance (heuristic) between the grid state and that of the solution.
		double estimatedCost = node.getValue().calculateDistance(solutionState);
		node.setEstimatedCost(estimatedCost);
		
		fringe.add(node);
		
		while (!fringe.isEmpty())
		{
			node = fringe.remove();
			
			// Return the node if it is the solution state.
			if (node.getValue().equals(solutionState))
				return returnSolution(node);
			
			expandNode(node);
			
			int i = 1;
			
			if (debugMode)
			{
				System.out.println("===== A* Heuristic Search information =====\n");
				System.out.println("Depth at " + (node.getDepth() + 1) + "\n");
			}
			
			// For each expanded child node, calculate the estimated cost using the current depth and Manhattan distance (heuristic), and put it into the PriorityQueue.
			for (Node childNode : node.getChildren())
			{
				double heuristic = childNode.getValue().calculateDistance(solutionState);
				estimatedCost = childNode.getDepth() + heuristic;
			
				if (debugMode)
				{
					System.out.println("Child " + i + ":");
					System.out.println("Heuristic: " + heuristic);
				System.out.println("Evaluation function value: " + estimatedCost + "\n");
				}
			
				childNode.setEstimatedCost(estimatedCost);
			
				fringe.add(childNode);
			
				i++;
			}
		}
	
		return null;
	}
}
\end{lstlisting}
		
	\end{appendices}
	
\end{document}